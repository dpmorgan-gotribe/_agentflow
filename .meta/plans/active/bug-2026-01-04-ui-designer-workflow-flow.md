# Bug Fix: UI Designer Not Creating Initial Mockup/Styleguide Before Screen Generation

**Created:** 2026-01-04
**Status:** Complete
**Completed:** 2026-01-04
**Category:** Bug Fix - Workflow Data Flow

## Problem Statement

The UI Designer agent is not following the expected design workflow:

1. ❌ **Missing Step**: Create an initial mockup/styleguide/kitchen sink with ALL components identified by the analyst
2. ❌ **Missing Step**: Wait for user approval of the style
3. ❌ **Missing Step**: Only THEN create all screens using the approved style/components

Currently, the workflow jumps directly to screen generation without the intermediate styleguide/mega page phase.

## Root Cause Analysis

After thorough investigation of the codebase, I identified **5 critical gaps** in the data flow:

### Gap 1: Analyst Output Not Propagated to State

**Location:** `packages/langgraph/src/nodes/execute.ts`, `apps/api/src/modules/workflow/agent-adapter.ts`

The Analyst agent generates:
- `stylePackages` (array of 5 distinct style packages)
- `componentInventory` (all UI components needed)
- `screens` (all screens identified)
- `userFlows` (user journeys)

**Problem:** These are stored in `agentOutputs[].result` but NEVER extracted into the proper state channels:
- `state.stylePackages` → remains empty
- `state.componentInventory` → remains null
- `state.designPhase` → never updated

**Evidence:**
```typescript
// packages/langgraph/src/state.ts (lines 377-426)
stylePackages: Annotation<StylePackage[]>({
  reducer: replaceReducer,
  default: () => [],  // Always empty!
}),
componentInventory: Annotation<ComponentInventory | null>({
  reducer: lastValue,
  default: () => null,  // Always null!
}),
```

### Gap 2: Orchestrator Thinking Doesn't See Style Packages

**Location:** `packages/langgraph/src/nodes/think.ts`, `packages/langgraph/src/prompts/orchestrator-thinking.ts`

The orchestrator's `buildThinkingContext()` function checks for `state.stylePackages`:
```typescript
// packages/langgraph/src/prompts/orchestrator-thinking.ts (lines 326-328)
if (state.stylePackages && state.stylePackages.length > 0) {
  sections.push(`## Available Style Packages\n${state.stylePackages.length} style packages generated by Analyst`);
}
```

**Problem:** Since `state.stylePackages` is never populated, the orchestrator never knows style packages exist, so it never triggers parallel UI designer dispatch for mega pages.

### Gap 3: Parallel Dispatch Doesn't Pass Style Package to Agent

**Location:** `packages/langgraph/src/nodes/parallel-dispatch.ts`

The parallel dispatch tries to find the style package:
```typescript
// packages/langgraph/src/nodes/parallel-dispatch.ts (lines 102-104)
const stylePackage = dispatch.stylePackageId && state.stylePackages
  ? state.stylePackages.find((s) => (s as { id: string }).id === dispatch.stylePackageId)
  : undefined;
```

**Problem:**
1. `state.stylePackages` is empty (Gap 1)
2. Even if found, `stylePackage` is never passed to the agent context!

### Gap 4: Agent Adapter Doesn't Inject Style Package Context

**Location:** `apps/api/src/modules/workflow/agent-adapter.ts`

The agent adapter builds context items:
```typescript
// apps/api/src/modules/workflow/agent-adapter.ts (lines 277-302)
const contextItems: ContextItem[] = [
  { type: ContextTypeEnum.CURRENT_TASK, ... },
  { type: ContextTypeEnum.WORKFLOW_SETTINGS, ... },
];
// Then adds AGENT_OUTPUTS from previous agents
```

**Problem:** It never adds:
- `style_package` context item for UI Designer mega page mode
- `component_inventory` context item for UI Designer
- The UIDesignerRequest properties like `stylePackage`, `componentInventory`, `isMegaPageRequest`

### Gap 5: UI Designer Mode Detection Fails

**Location:** `packages/agents/src/agents/ui-designer.ts`

The UI Designer checks for mega page mode:
```typescript
// packages/agents/src/agents/ui-designer.ts (lines 293-299)
const stylePackageContext = context.items.find(
  (i) => i.type === 'style_package' as never
);
if (stylePackageContext?.content) {
  return this.buildMegaPageSystemPrompt(stylePackageContext.content as StylePackage);
}
```

**Problem:** No `style_package` context item is ever added, so mega page mode is never triggered.

---

## ⚠️ CRITICAL: File-Based Context Pattern

**Related Plan:** `bug-2026-01-03-ui-designer-json-parse.md`

### The Problem with Direct Context Passing

Passing large data structures directly in agent context causes:
- **Token explosion**: Style packages (5x) + component inventory + screens + user flows = 50-100KB
- **Context truncation**: Claude may truncate or lose important details
- **Memory pressure**: Multiple parallel designers each receive full copies
- **JSON parsing failures**: Same issue we fixed for outputs

### The Solution: File-Based Context References

Just as we fixed outputs to use file paths instead of inline content, **inputs should also use file references**:

```
❌ BAD: Pass full style package in context (50KB per designer)
{
  type: 'style_package',
  content: { /* 50KB of style data */ }
}

✅ GOOD: Pass file path, agent reads when needed (100 bytes)
{
  type: 'style_package',
  documentRef: 'designs/research/style-packages/modern-minimal.json'
}
```

### Context Size Comparison

| Data | Direct (Current) | File-Based (New) |
|------|------------------|------------------|
| Style Package | ~10KB inline | 80 bytes (path) |
| Component Inventory | ~20KB inline | 90 bytes (path) |
| Screens List | ~15KB inline | 70 bytes (path) |
| User Flows | ~10KB inline | 70 bytes (path) |
| **Total per Designer** | **~55KB** | **~310 bytes** |
| **5 Parallel Designers** | **~275KB** | **~1.5KB** |

---

## Expected Workflow Flow

```
┌─────────────┐
│   START     │
└─────┬───────┘
      │
      ▼
┌─────────────┐     Outputs: stylePackages[], componentInventory, screens[], userFlows[]
│  ANALYST    │ ──► WRITES TO FILES:
└─────┬───────┘       designs/research/style-packages/*.json
      │               designs/research/component-inventory.json
      │               designs/research/screens.json
      │               designs/research/user-flows.json
      ▼
┌─────────────┐     state.stylePackagePaths = [path1, path2, ...]
│ EXTRACT TO  │     state.componentInventoryPath = path
│   STATE     │     state.designPhase = 'stylesheet'
└─────┬───────┘
      │
      ▼
┌─────────────┐
│  ARCHITECT  │
└─────┬───────┘
      │
      ▼
┌─────────────────────────────────────────────────────────────────┐
│                    PARALLEL UI DESIGNERS                         │
│  Each receives: { stylePackagePath, componentInventoryPath }     │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐  ┌────────────┐ │
│  │ Designer 1 │  │ Designer 2 │  │ Designer 3 │  │ Designer 4 │...│
│  │ READS file │  │ READS file │  │ READS file │  │ READS file │ │
│  │ Mega Page  │  │ Mega Page  │  │ Mega Page  │  │ Mega Page  │ │
│  └────────────┘  └────────────┘  └────────────┘  └────────────┘ │
└─────────────────────────────────────────────────────────────────┘
      │
      ▼
┌─────────────────────┐
│  USER APPROVAL      │  User selects ONE style from the mega pages
│  (Style Selection)  │
└─────────┬───────────┘
          │
          ▼ (on approval)
     ┌────────────────────────────────────────────────────────────┐
     │                 state.selectedStyleId = chosen style       │
     │                 state.approvedStylePath = path to selected │
     │                 state.stylesheetApproved = true            │
     │                 state.designPhase = 'screens'              │
     └────────────────────────────────────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────────────────────────────┐
│                    PARALLEL UI DESIGNERS                         │
│  Each receives: { approvedStylePath, screenPath, ... }          │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐  ┌────────────┐ │
│  │ Screen 1   │  │ Screen 2   │  │ Screen 3   │  │ Screen 4   │...│
│  │ READS      │  │ READS      │  │ READS      │  │ READS      │ │
│  │ approved   │  │ approved   │  │ approved   │  │ approved   │ │
│  │ style file │  │ style file │  │ style file │  │ style file │ │
│  └────────────┘  └────────────┘  └────────────┘  └────────────┘ │
└─────────────────────────────────────────────────────────────────┘
      │
      ▼
┌─────────────────────┐
│  USER APPROVAL      │  User reviews all screens
│  (Design Review)    │
└─────────┬───────────┘
          │
          ▼
┌─────────────────────┐
│  PROJECT MANAGER    │  Creates tasks with design references
└─────────────────────┘
```

---

## Implementation Plan

### Step 1: Analyst Writes Research to Files

**File:** `packages/agents/src/agents/analyst.ts`

After generating style research, write to files instead of returning inline:

```typescript
// Write each style package to its own file
for (const pkg of styleResearch.stylePackages) {
  const path = `designs/research/style-packages/${pkg.id}.json`;
  await writeFile(projectPath, path, JSON.stringify(pkg, null, 2));
}

// Write component inventory
await writeFile(projectPath, 'designs/research/component-inventory.json',
  JSON.stringify(styleResearch.componentInventory, null, 2));

// Write screens
await writeFile(projectPath, 'designs/research/screens.json',
  JSON.stringify(styleResearch.screens, null, 2));

// Return paths instead of content
return {
  stylePackagePaths: styleResearch.stylePackages.map(p =>
    `designs/research/style-packages/${p.id}.json`
  ),
  componentInventoryPath: 'designs/research/component-inventory.json',
  screensPath: 'designs/research/screens.json',
  userFlowsPath: 'designs/research/user-flows.json',
};
```

### Step 2: Update State Channels for Paths

**File:** `packages/langgraph/src/state.ts`

Add path-based state channels alongside existing ones:

```typescript
// File paths for analyst research output
stylePackagePaths: Annotation<string[]>({
  reducer: replaceReducer,
  default: () => [],
}),
componentInventoryPath: Annotation<string | null>({
  reducer: lastValue,
  default: () => null,
}),
screensPath: Annotation<string | null>({
  reducer: lastValue,
  default: () => null,
}),
userFlowsPath: Annotation<string | null>({
  reducer: lastValue,
  default: () => null,
}),
// Path to the user-approved style package
approvedStylePath: Annotation<string | null>({
  reducer: lastValue,
  default: () => null,
}),
```

### Step 3: Extract Analyst Output to State (Paths)

**File:** `packages/langgraph/src/nodes/execute.ts`

After analyst completes, extract file paths to state:

```typescript
if (agentId === 'analyst' || agentId === 'analyzer') {
  const result = agentOutput.result as AnalystPathsOutput;
  if (result?.stylePackagePaths?.length > 0) {
    return {
      ...currentStateUpdate,
      stylePackagePaths: result.stylePackagePaths,
      componentInventoryPath: result.componentInventoryPath,
      screensPath: result.screensPath,
      userFlowsPath: result.userFlowsPath,
      designPhase: 'stylesheet' as const,
    };
  }
}
```

### Step 4: Update Agent Context Interface for Document Refs

**File:** `packages/agents/src/types.ts`

The `ContextItem` already supports `documentRef`:
```typescript
export const ContextItemSchema = z.object({
  type: ContextTypeSchema,
  content: z.unknown(),
  metadata: z.object({ ... }),
  /** Path to document file (bypasses token budget when set) */
  documentRef: z.string().optional(),  // ✅ Already exists!
});
```

### Step 5: Update Agent Adapter to Pass Document Refs

**File:** `apps/api/src/modules/workflow/agent-adapter.ts`

When executing UI Designer, pass file paths not content:

```typescript
// For mega page mode (style competition)
if (agentType === AgentTypeEnum.UI_DESIGNER && dispatch.stylePackagePath) {
  contextItems.push({
    type: ContextTypeEnum.STYLE_PACKAGE,
    content: null,  // Don't pass content
    documentRef: dispatch.stylePackagePath,  // Pass path
    metadata: {
      source: 'analyst',
      timestamp: new Date(),
      relevance: 1,
    },
  });

  contextItems.push({
    type: ContextTypeEnum.COMPONENT_INVENTORY,
    content: null,
    documentRef: state.componentInventoryPath,
    metadata: { source: 'analyst', timestamp: new Date(), relevance: 1 },
  });
}

// For screen generation (after approval)
if (agentType === AgentTypeEnum.UI_DESIGNER && state.approvedStylePath) {
  contextItems.push({
    type: ContextTypeEnum.STYLE_PACKAGE,
    content: null,
    documentRef: state.approvedStylePath,  // Approved style
    metadata: { source: 'user_approved', timestamp: new Date(), relevance: 1 },
  });
}
```

### Step 6: Update UI Designer to Read from Files

**File:** `packages/agents/src/agents/ui-designer.ts`

Update mega page mode detection to use documentRef:

```typescript
protected buildSystemPrompt(context: AgentContext): string {
  // Check for style package via document reference
  const stylePackageContext = context.items.find(
    (i) => i.type === ContextTypeEnum.STYLE_PACKAGE
  );

  if (stylePackageContext?.documentRef) {
    // Mega page mode - agent will read file
    return this.buildMegaPageSystemPrompt(stylePackageContext.documentRef);
  }

  // ... default mode
}

private buildMegaPageSystemPrompt(stylePackagePath: string): string {
  return `
You are a UI Designer creating a mega page (kitchen sink) showcasing ALL components.

## Input Files (READ THESE FIRST)
- Style Package: ${stylePackagePath}
- Component Inventory: designs/research/component-inventory.json

## Instructions
1. Read the style package file to understand colors, typography, etc.
2. Read the component inventory to see ALL components you must showcase
3. Create a single HTML page demonstrating every component
4. Write output to: designs/mockups/mega-page-{styleId}.html
5. Return only the file path in your response

## Output Format
{
  "megaPagePath": "designs/mockups/mega-page-modern-minimal.html",
  "componentsShowcased": 47,
  "success": true
}
`;
}
```

### Step 7: Update Parallel Dispatch for Path-Based Dispatch

**File:** `packages/langgraph/src/nodes/parallel-dispatch.ts`

Pass style package path instead of content:

```typescript
// Build dispatch for each style package
const dispatches: AgentDispatch[] = state.stylePackagePaths.map((path, i) => ({
  agentId: 'ui_designer',
  executionId: crypto.randomUUID(),
  stylePackagePath: path,  // Pass path, not content
  componentInventoryPath: state.componentInventoryPath,
  contextRefs: [],
}));
```

### Step 8: Update AgentDispatch Schema

**File:** `packages/langgraph/src/schemas/orchestrator-thinking.ts`

Add path fields to dispatch:

```typescript
export const AgentDispatchSchema = z.object({
  agentId: z.string(),
  executionId: z.string().optional(),
  stylePackageId: z.string().optional(),
  // NEW: File-based context
  stylePackagePath: z.string().optional(),
  componentInventoryPath: z.string().optional(),
  screenPath: z.string().optional(),
  contextRefs: z.array(z.string()).optional(),
});
```

---

## Files to Modify

| File | Changes |
|------|---------|
| `packages/agents/src/agents/analyst.ts` | Write research output to files |
| `packages/langgraph/src/state.ts` | Add path-based state channels |
| `packages/langgraph/src/nodes/execute.ts` | Extract analyst paths to state |
| `packages/agents/src/types.ts` | Add STYLE_PACKAGE, COMPONENT_INVENTORY context types |
| `apps/api/src/modules/workflow/agent-adapter.ts` | Pass documentRef instead of content |
| `packages/agents/src/agents/ui-designer.ts` | Read from files, use documentRef |
| `packages/langgraph/src/nodes/parallel-dispatch.ts` | Pass paths in dispatch |
| `packages/langgraph/src/schemas/orchestrator-thinking.ts` | Add path fields to dispatch |
| `apps/api/src/modules/workflow/workflow.service.ts` | Emit style competition events |

---

## Directory Structure for Research Output

```
.aigentflow/projects/{project-name}/
└── designs/
    └── research/
        ├── style-packages/
        │   ├── modern-minimal.json      (~10KB)
        │   ├── bold-vibrant.json        (~10KB)
        │   ├── elegant-classic.json     (~10KB)
        │   ├── playful-friendly.json    (~10KB)
        │   └── professional-clean.json  (~10KB)
        ├── component-inventory.json     (~20KB)
        ├── screens.json                 (~15KB)
        └── user-flows.json              (~10KB)
```

---

## Testing Strategy

1. **Unit Test:** Verify analyst writes files correctly
2. **Unit Test:** Verify state contains paths (not content)
3. **Unit Test:** Verify agent adapter passes documentRef
4. **Unit Test:** Verify UI Designer reads from files
5. **Integration Test:** Full workflow with file-based context
6. **E2E Test:** Web UI shows style competition with previews

---

## Success Criteria

- [x] Analyst writes style packages to individual files
- [x] Analyst writes component inventory to file
- [x] State channels contain file paths, not content
- [x] Each UI Designer receives only ~300 bytes of context (paths)
- [x] Each UI Designer reads files using Claude's file read capability
- [ ] Mega pages are generated successfully (requires E2E test)
- [ ] Style approval updates `approvedStylePath` (requires E2E test)
- [ ] Screen generation uses approved style from file (requires E2E test)

---

## Current Step

**Complete:** Implementation finished 2026-01-04

All 8 implementation steps completed:
1. ✅ Analyst writes research to files (already done, exported `StyleResearchPaths`)
2. ✅ Added path-based state channels to `state.ts`
3. ✅ Extract analyst file paths to state in `execute.ts` with `extractAnalystStyleResearch()`
4. ✅ Agent adapter passes `documentRef` context items
5. ✅ UI Designer reads from files via `hydrateContextItems()` and `override execute()`
6. ✅ Parallel dispatch uses paths in `designResearchPaths`
7. ✅ Updated `AgentDispatchSchema` with file path fields
8. ✅ Fixed TypeScript errors and verified typecheck passes

Ready for E2E testing to verify the workflow end-to-end.

---

## Notes

- This plan builds on `bug-2026-01-03-ui-designer-json-parse.md` which established file-based outputs
- The `documentRef` field already exists in `ContextItemSchema` - we're using existing infrastructure
- File-based context enables future improvements like incremental updates, caching, and versioning
- Claude CLI can read files directly, so the agent reads the file content itself

---

## References

- `bug-2026-01-03-ui-designer-json-parse.md` - File-based output pattern
- `packages/agents/src/types.ts:261-276` - ContextItemSchema with documentRef
- `packages/agents/src/agents/analyst.ts:224-268` - Analyst parses and returns styleResearch
- `packages/agents/src/schemas/analyst-style-output.ts:394-452` - StyleResearchOutput schema
- `packages/agents/src/agents/ui-designer.ts:1005-1083` - Mega page system prompt
- `packages/langgraph/src/prompts/orchestrator-thinking.ts:59-243` - Workflow phases documentation
- `packages/langgraph/src/nodes/parallel-dispatch.ts:48-157` - Parallel execution implementation
