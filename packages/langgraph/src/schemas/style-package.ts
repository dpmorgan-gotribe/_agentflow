/**
 * Style Package Schemas
 *
 * Defines the structures for style packages generated by the Analyst
 * and used in the style competition workflow where multiple UI designers
 * create mockups from different style packages.
 */

import { z } from 'zod';

/**
 * Typography configuration for a style package
 */
export const TypographySchema = z.object({
  /** Primary font for headings */
  headingFont: z.string(),
  /** Secondary font for body text */
  bodyFont: z.string(),
  /** Font weights to use */
  weights: z.array(z.number()),
  /** Source of fonts (google, adobe, local) */
  source: z.enum(['google', 'adobe', 'local', 'system']),
  /** Font import URL if external */
  importUrl: z.string().optional(),
  /** Base font size in pixels */
  baseFontSize: z.number().default(16),
  /** Type scale ratio (e.g., 1.25 for major third) */
  typeScale: z.number().default(1.25),
});

export type Typography = z.infer<typeof TypographySchema>;

/**
 * Icon library configuration
 */
export const IconConfigSchema = z.object({
  /** Icon library name */
  library: z.enum([
    'lucide',
    'heroicons',
    'phosphor',
    'feather',
    'tabler',
    'material',
    'fontawesome',
    'iconoir',
    'radix',
  ]),
  /** Icon style variant */
  style: z.enum(['outline', 'solid', 'duotone', 'thin', 'regular']),
  /** Source URL or package name */
  source: z.string(),
  /** CDN or import URL */
  importUrl: z.string().optional(),
});

export type IconConfig = z.infer<typeof IconConfigSchema>;

/**
 * Color palette configuration
 */
export const ColorPaletteSchema = z.object({
  /** Primary brand color */
  primary: z.string(),
  /** Secondary brand color */
  secondary: z.string(),
  /** Accent color for highlights */
  accent: z.string(),
  /** Background color */
  background: z.string(),
  /** Surface color (cards, modals) */
  surface: z.string(),
  /** Primary text color */
  text: z.string(),
  /** Muted text color */
  textMuted: z.string(),
  /** Success state color */
  success: z.string(),
  /** Warning state color */
  warning: z.string(),
  /** Error state color */
  error: z.string(),
  /** Info state color */
  info: z.string(),
  /** Full palette with shades (50-900) */
  palette: z.record(z.string(), z.record(z.string(), z.string())).optional(),
});

export type ColorPalette = z.infer<typeof ColorPaletteSchema>;

/**
 * Visual style properties
 */
export const VisualStyleSchema = z.object({
  /** Border radius configuration */
  borderRadius: z.object({
    none: z.string().default('0'),
    sm: z.string().default('0.125rem'),
    default: z.string().default('0.25rem'),
    md: z.string().default('0.375rem'),
    lg: z.string().default('0.5rem'),
    xl: z.string().default('0.75rem'),
    '2xl': z.string().default('1rem'),
    full: z.string().default('9999px'),
  }),
  /** Box shadow configuration */
  shadows: z.object({
    sm: z.string(),
    default: z.string(),
    md: z.string(),
    lg: z.string(),
    xl: z.string(),
  }),
  /** Whether to use gradients */
  useGradients: z.boolean().default(false),
  /** Gradient definitions if used */
  gradients: z.array(z.object({
    name: z.string(),
    value: z.string(),
  })).optional(),
  /** Animation/transition preferences */
  animations: z.object({
    /** Enable animations */
    enabled: z.boolean().default(true),
    /** Transition duration */
    duration: z.string().default('150ms'),
    /** Easing function */
    easing: z.string().default('ease-in-out'),
    /** Reduce motion preference */
    reduceMotion: z.boolean().default(false),
  }),
});

export type VisualStyle = z.infer<typeof VisualStyleSchema>;

/**
 * CSS framework configuration
 */
export const CssConfigSchema = z.object({
  /** CSS framework to use */
  framework: z.enum([
    'tailwind',
    'vanilla',
    'css-modules',
    'styled-components',
    'emotion',
  ]),
  /** Dark mode strategy */
  darkMode: z.enum(['class', 'media', 'none']).default('class'),
  /** CSS variable prefix */
  cssPrefix: z.string().default('--af'),
  /** Use CSS layers */
  useLayers: z.boolean().default(false),
});

export type CssConfig = z.infer<typeof CssConfigSchema>;

/**
 * Design reference/inspiration source
 */
export const DesignReferenceSchema = z.object({
  /** Name of the reference */
  name: z.string(),
  /** URL to the reference */
  url: z.string().url(),
  /** Notes about what to take from this reference */
  notes: z.string(),
  /** What aspects are relevant */
  aspects: z.array(z.enum([
    'color',
    'typography',
    'layout',
    'components',
    'animation',
    'iconography',
    'spacing',
    'overall_vibe',
  ])).optional(),
});

export type DesignReference = z.infer<typeof DesignReferenceSchema>;

/**
 * Complete style package generated by Analyst
 */
export const StylePackageSchema = z.object({
  /** Unique identifier for this style */
  id: z.string(),
  /** Human-readable name for the style */
  name: z.string(),
  /** Typography configuration */
  typography: TypographySchema,
  /** Icon library configuration */
  icons: IconConfigSchema,
  /** Color palette */
  colors: ColorPaletteSchema,
  /** Visual style properties */
  visual: VisualStyleSchema,
  /** CSS framework configuration */
  css: CssConfigSchema,
  /** Design references and inspiration */
  references: z.array(DesignReferenceSchema),
  /** Mood/vibe description */
  moodDescription: z.string(),
  /** Target audience for this style */
  targetAudience: z.string().optional(),
  /** Key characteristics of this style */
  characteristics: z.array(z.string()),
  /** What makes this style unique */
  differentiator: z.string(),
  /** Whether this style honors user constraints from prompt */
  honorsUserHints: z.boolean().default(true),
  /** Which user hints this style incorporates */
  userHintsUsed: z.array(z.string()).optional(),
});

export type StylePackage = z.infer<typeof StylePackageSchema>;

/**
 * User feedback when rejecting a style
 */
export const StyleFeedbackSchema = z.object({
  /** What the user didn't like */
  dislikes: z.array(z.string()),
  /** What direction they want instead */
  wantedInstead: z.string().optional(),
  /** Specific elements to avoid */
  avoid: z.array(z.string()).optional(),
  /** Specific elements to keep */
  keep: z.array(z.string()).optional(),
});

export type StyleFeedback = z.infer<typeof StyleFeedbackSchema>;

/**
 * Record of a rejected style (to avoid in future iterations)
 */
export const RejectedStyleSchema = z.object({
  /** ID of the rejected style package */
  styleId: z.string(),
  /** Name of the rejected style */
  styleName: z.string(),
  /** Iteration when this was rejected */
  iteration: z.number(),
  /** Timestamp of rejection */
  rejectedAt: z.string(),
  /** User feedback for why it was rejected */
  feedback: StyleFeedbackSchema.optional(),
  /** Raw feedback text from user */
  rawFeedback: z.string().optional(),
  /** Key characteristics to avoid in future */
  avoidCharacteristics: z.array(z.string()),
});

export type RejectedStyle = z.infer<typeof RejectedStyleSchema>;

/**
 * Style selection result from approval
 */
export const StyleSelectionSchema = z.object({
  /** ID of the selected style */
  selectedStyleId: z.string(),
  /** The full style package that was selected */
  selectedStyle: StylePackageSchema,
  /** Iteration when selection was made */
  iteration: z.number(),
  /** Timestamp of selection */
  selectedAt: z.string(),
  /** Any modifications requested */
  modifications: z.array(z.string()).optional(),
});

export type StyleSelection = z.infer<typeof StyleSelectionSchema>;

/**
 * User hints extracted from the prompt
 */
export const UserStyleHintsSchema = z.object({
  /** Explicit color mentions */
  colors: z.array(z.string()),
  /** Font mentions */
  fonts: z.array(z.string()),
  /** Inspiration URLs provided */
  inspirationUrls: z.array(z.string()),
  /** Mood/vibe keywords */
  moodKeywords: z.array(z.string()),
  /** Platform mentions (iOS, Material, etc.) */
  platformHints: z.array(z.string()),
  /** Explicit style mentions (minimal, bold, etc.) */
  styleKeywords: z.array(z.string()),
  /** Things to avoid */
  avoidKeywords: z.array(z.string()),
});

export type UserStyleHints = z.infer<typeof UserStyleHintsSchema>;

/**
 * Style competition state
 */
export const StyleCompetitionStateSchema = z.object({
  /** Current iteration (1-5) */
  iteration: z.number().min(1).max(5),
  /** All style packages in current competition */
  stylePackages: z.array(StylePackageSchema),
  /** Mega page previews generated by UI designers */
  megaPagePreviews: z.array(z.object({
    styleId: z.string(),
    previewPath: z.string(),
    thumbnailPath: z.string().optional(),
    generatedAt: z.string(),
  })),
  /** History of rejected styles */
  rejectedStyles: z.array(RejectedStyleSchema),
  /** User hints extracted from prompt */
  userHints: UserStyleHintsSchema.optional(),
  /** Final selection (when approved) */
  selection: StyleSelectionSchema.optional(),
  /** Whether competition is complete */
  isComplete: z.boolean().default(false),
  /** Status of the competition */
  status: z.enum([
    'researching',      // Analyst generating packages
    'generating',       // UI designers creating mega pages
    'awaiting_selection', // Waiting for user to pick
    'selected',         // User picked a style
    'exhausted',        // Max iterations reached
  ]).default('researching'),
});

export type StyleCompetitionState = z.infer<typeof StyleCompetitionStateSchema>;

/**
 * Helper to create an empty user style hints object
 */
export function createEmptyUserHints(): UserStyleHints {
  return {
    colors: [],
    fonts: [],
    inspirationUrls: [],
    moodKeywords: [],
    platformHints: [],
    styleKeywords: [],
    avoidKeywords: [],
  };
}

/**
 * Helper to create initial style competition state
 */
export function createInitialCompetitionState(): StyleCompetitionState {
  return {
    iteration: 1,
    stylePackages: [],
    megaPagePreviews: [],
    rejectedStyles: [],
    isComplete: false,
    status: 'researching',
  };
}

/**
 * Helper to record a style rejection
 */
export function createRejectedStyle(
  style: StylePackage,
  iteration: number,
  feedback?: StyleFeedback,
  rawFeedback?: string
): RejectedStyle {
  return {
    styleId: style.id,
    styleName: style.name,
    iteration,
    rejectedAt: new Date().toISOString(),
    feedback,
    rawFeedback,
    avoidCharacteristics: style.characteristics,
  };
}

/**
 * Helper to check if we've exhausted style iterations
 */
export function isStyleIterationExhausted(
  state: StyleCompetitionState,
  maxIterations: number = 5
): boolean {
  return state.iteration >= maxIterations && !state.selection;
}
